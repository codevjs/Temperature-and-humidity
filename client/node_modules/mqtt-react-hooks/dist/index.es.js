import n,{createContext as e,useContext as o,useState as t,useCallback as c,useEffect as r,useRef as l,useMemo as i}from"react";import{matches as s}from"mqtt-pattern";import{connect as u}from"mqtt";var a=e({});function f(n,e={}){const{client:l,connectionStatus:i,parserMethod:u}=o(a),[f,d]=t(void 0),g=c((async()=>{null==l||l.subscribe(n,e)}),[l,e,n]),m=c(((e,o)=>{[n].flat().some((n=>s(n,e)))&&d({topic:e,message:(null==u?void 0:u(o))||o.toString()})}),[u,n]);return r((()=>((null==l?void 0:l.connected)&&(g(),l.on("message",m)),()=>{null==l||l.off("message",m)})),[m,l,g]),{client:l,topic:n,message:f,connectionStatus:i}}function d(){const{connectionStatus:n,client:e,parserMethod:t}=o(a);return{connectionStatus:n,client:e,parserMethod:t}}function g({children:e,brokerUrl:o,options:c={keepalive:0},parserMethod:s}){const f=l(!1),[d,g]=t("Offline"),[m,p]=t(null);r((()=>{if(!m&&!f.current){f.current=!0,g("Connecting"),console.log(`attempting to connect to ${o}`);const n=u(o,c);n.on("connect",(()=>{console.debug("on connect"),g("Connected"),p(n)})),n.on("reconnect",(()=>{console.debug("on reconnect"),g("Reconnecting")})),n.on("error",(n=>{console.log(`Connection error: ${n}`),g(n.message)})),n.on("offline",(()=>{console.debug("on offline"),g("Offline")})),n.on("end",(()=>{console.debug("on end"),g("Offline")}))}}),[m,f,o,c]),r((()=>()=>{m&&(console.log("closing mqtt client"),m.end(!0),p(null),f.current=!1)}),[m,f]);const b=i((()=>({connectionStatus:d,client:m,parserMethod:s})),[d,m,s]);return n.createElement(a.Provider,{value:b},e)}export{g as Connector,a as MqttContext,d as useMqttState,f as useSubscription};
//# sourceMappingURL=index.es.js.map
