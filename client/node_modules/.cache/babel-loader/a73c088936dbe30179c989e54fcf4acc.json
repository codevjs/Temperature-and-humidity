{"ast":null,"code":"// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n'use strict';\n\nconst SortedSet = require('js-sdsl').Set;\n\nconst debugTrace = require('debug')('number-allocator:trace');\n\nconst debugError = require('debug')('number-allocator:error');\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\n\n\nfunction Interval(low, high) {\n  this.low = low;\n  this.high = high;\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high;\n};\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1;\n  if (other.low < this.low && other.high < this.low) return 1;\n  return 0;\n};\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\n\n\nfunction NumberAllocator(min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max);\n  }\n\n  this.min = min;\n  this.max = max;\n  this.ss = new SortedSet([], (lhs, rhs) => {\n    return lhs.compare(rhs);\n  });\n  debugTrace('Create');\n  this.clear();\n}\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\n\n\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null;\n  return this.ss.front().low;\n};\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\n\n\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty');\n    return null;\n  }\n\n  const it = this.ss.front();\n  const num = it.low;\n\n  if (num + 1 <= it.high) {\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|----|\n    ++it.low;\n  } else {\n    this.ss.eraseElementByPos(0);\n  }\n\n  debugTrace('alloc():' + num);\n  return num;\n};\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\n\n\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (it) {\n    if (it.equals(key)) {\n      // |x|\n      this.ss.eraseElementByValue(it);\n      debugTrace('use():' + num);\n      return true;\n    } // x |-----|\n\n\n    if (it.low > num) return false; // |x----|\n\n    if (it.low === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // x|----|\n      ++it.low;\n      debugTrace('use():' + num);\n      return true;\n    } // |----x|\n\n\n    if (it.high === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // |----|x\n      --it.high;\n      debugTrace('use():' + num);\n      return true;\n    }\n\n    const low = it.low; // |--x--|\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|--|\n\n    it.low = num + 1; // |--|x|--|\n\n    this.ss.insert(new Interval(low, num - 1));\n    debugTrace('use():' + num);\n    return true;\n  }\n\n  debugTrace('use():failed');\n  return false;\n};\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\n\n\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range');\n    return;\n  }\n\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (it) {\n    if (it.low <= num && num <= it.high) {\n      debugError('free():' + num + ' has already been vacant');\n      return;\n    }\n\n    if (it === this.ss.front()) {\n      // v....\n      if (num + 1 === it.low) {\n        // Concat to right\n        // Overwrite the interval in the ss but it is safe,\n        // because no order violation is happened.\n        --it.low;\n      } else {\n        // Insert new interval\n        this.ss.insert(key);\n      }\n    } else {\n      // ..v..\n      const itl = this.ss.reverseLowerBound(key);\n\n      if (itl.high + 1 === num) {\n        if (num + 1 === it.low) {\n          // Concat to left and right\n          this.ss.eraseElementByValue(itl); // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n\n          it.low = itl.low;\n        } else {\n          // Concat to left\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          itl.high = num;\n        }\n      } else {\n        if (num + 1 === it.low) {\n          // Concat to right\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = num;\n        } else {\n          // Insert new interval\n          this.ss.insert(key);\n        }\n      }\n    }\n  } else {\n    // ....v\n    if (it === this.ss.front()) {\n      // Insert new interval\n      this.ss.insert(key);\n      return;\n    }\n\n    const itl = this.ss.reverseLowerBound(key);\n\n    if (itl.high + 1 === num) {\n      // Concat to left\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      itl.high = num;\n    } else {\n      // Insert new interval\n      this.ss.insert(key);\n    }\n  }\n\n  debugTrace('free():' + num);\n};\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\n\n\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()');\n  this.ss.clear();\n  this.ss.insert(new Interval(this.min, this.max));\n};\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\n\n\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size();\n};\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\n\n\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size());\n\n  for (const element of this.ss) {\n    console.log(element);\n  }\n};\n\nmodule.exports = NumberAllocator;","map":{"version":3,"names":["SortedSet","require","Set","debugTrace","debugError","Interval","low","high","prototype","equals","other","compare","NumberAllocator","min","max","ss","lhs","rhs","clear","firstVacant","size","front","alloc","it","num","eraseElementByPos","use","key","lowerBound","eraseElementByValue","insert","free","itl","reverseLowerBound","intervalCount","dump","console","log","element","module","exports"],"sources":["/Users/Neutron/Project/Trisno/client/node_modules/number-allocator/lib/number-allocator.js"],"sourcesContent":["// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict'\n\nconst SortedSet = require('js-sdsl').Set\nconst debugTrace = require('debug')('number-allocator:trace')\nconst debugError = require('debug')('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.front()\n  const num = it.low\n  if (num + 1 <= it.high) {\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|----|\n    ++it.low\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (it) {\n    if (it.equals(key)) {\n      // |x|\n      this.ss.eraseElementByValue(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (it.low > num) return false\n\n    // |x----|\n    if (it.low === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // x|----|\n      ++it.low\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (it.high === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // |----|x\n      --it.high\n      debugTrace('use():' + num)\n      return true\n    }\n\n    const low = it.low\n\n    // |--x--|\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|--|\n    it.low = num + 1\n\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (it) {\n    if (it.low <= num && num <= it.high) {\n      debugError('free():' + num + ' has already been vacant')\n      return\n    }\n    if (it === this.ss.front()) {\n      // v....\n      if (num + 1 === it.low) {\n        // Concat to right\n        // Overwrite the interval in the ss but it is safe,\n        // because no order violation is happened.\n        --it.low\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const itl = this.ss.reverseLowerBound(key)\n      if (itl.high + 1 === num) {\n        if (num + 1 === it.low) {\n          // Concat to left and right\n          this.ss.eraseElementByValue(itl)\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = itl.low\n        } else {\n          // Concat to left\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          itl.high = num\n        }\n      } else {\n        if (num + 1 === it.low) {\n          // Concat to right\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = num\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  } else {\n    // ....v\n    if (it === this.ss.front()) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    const itl = this.ss.reverseLowerBound(key)\n    if (itl.high + 1 === num) {\n      // Concat to left\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      itl.high = num\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}