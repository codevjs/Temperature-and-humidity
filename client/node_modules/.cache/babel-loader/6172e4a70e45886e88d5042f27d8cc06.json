{"ast":null,"code":"import n, { createContext as e, useContext as o, useState as t, useCallback as c, useEffect as r, useRef as l, useMemo as i } from \"react\";\nimport { matches as s } from \"mqtt-pattern\";\nimport { connect as u } from \"mqtt\";\nvar a = e({});\n\nfunction f(n) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    client: l,\n    connectionStatus: i,\n    parserMethod: u\n  } = o(a),\n        [f, d] = t(void 0),\n        g = c(async () => {\n    null == l || l.subscribe(n, e);\n  }, [l, e, n]),\n        m = c((e, o) => {\n    [n].flat().some(n => s(n, e)) && d({\n      topic: e,\n      message: (null == u ? void 0 : u(o)) || o.toString()\n    });\n  }, [u, n]);\n  return r(() => ((null == l ? void 0 : l.connected) && (g(), l.on(\"message\", m)), () => {\n    null == l || l.off(\"message\", m);\n  }), [m, l, g]), {\n    client: l,\n    topic: n,\n    message: f,\n    connectionStatus: i\n  };\n}\n\nfunction d() {\n  const {\n    connectionStatus: n,\n    client: e,\n    parserMethod: t\n  } = o(a);\n  return {\n    connectionStatus: n,\n    client: e,\n    parserMethod: t\n  };\n}\n\nfunction g(_ref) {\n  let {\n    children: e,\n    brokerUrl: o,\n    options: c = {\n      keepalive: 0\n    },\n    parserMethod: s\n  } = _ref;\n  const f = l(!1),\n        [d, g] = t(\"Offline\"),\n        [m, p] = t(null);\n  r(() => {\n    if (!m && !f.current) {\n      f.current = !0, g(\"Connecting\"), console.log(`attempting to connect to ${o}`);\n      const n = u(o, c);\n      n.on(\"connect\", () => {\n        console.debug(\"on connect\"), g(\"Connected\"), p(n);\n      }), n.on(\"reconnect\", () => {\n        console.debug(\"on reconnect\"), g(\"Reconnecting\");\n      }), n.on(\"error\", n => {\n        console.log(`Connection error: ${n}`), g(n.message);\n      }), n.on(\"offline\", () => {\n        console.debug(\"on offline\"), g(\"Offline\");\n      }), n.on(\"end\", () => {\n        console.debug(\"on end\"), g(\"Offline\");\n      });\n    }\n  }, [m, f, o, c]), r(() => () => {\n    m && (console.log(\"closing mqtt client\"), m.end(!0), p(null), f.current = !1);\n  }, [m, f]);\n  const b = i(() => ({\n    connectionStatus: d,\n    client: m,\n    parserMethod: s\n  }), [d, m, s]);\n  return n.createElement(a.Provider, {\n    value: b\n  }, e);\n}\n\nexport { g as Connector, a as MqttContext, d as useMqttState, f as useSubscription };","map":{"version":3,"mappings":"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","names":["MqttContext","createContext","topic","options","client","connectionStatus","parserMethod","useContext","message","setMessage","useState","undefined","subscribe","useCallback","async","callback","receivedTopic","receivedMessage","flat","some","rTopic","matches","toString","useEffect","connected","on","off","useMqttState","Connector","children","brokerUrl","keepalive","clientValid","useRef","setStatus","setClient","current","console","log","mqtt","connect","debug","err","end","value","useMemo","React","Provider"],"sources":["/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/Context.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/useSubscription.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/useMqttState.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/Connector.tsx"],"sourcesContent":["/* istanbul ignore file */\n\nimport { createContext } from 'react';\n\nimport { IMqttContext } from './types';\n\nexport default createContext<IMqttContext>({} as IMqttContext);\n","import { useContext, useEffect, useCallback, useState } from 'react';\n\nimport { IClientSubscribeOptions } from 'mqtt';\nimport { matches } from 'mqtt-pattern';\n\nimport MqttContext from './Context';\nimport { IMqttContext as Context, IUseSubscription, IMessage } from './types';\n\nexport default function useSubscription(\n  topic: string | string[],\n  options: IClientSubscribeOptions = {} as IClientSubscribeOptions,\n): IUseSubscription {\n  const { client, connectionStatus, parserMethod } = useContext<Context>(\n    MqttContext,\n  );\n\n  const [message, setMessage] = useState<IMessage | undefined>(undefined);\n\n  const subscribe = useCallback(async () => {\n    client?.subscribe(topic, options);\n  }, [client, options, topic]);\n\n  const callback = useCallback(\n    (receivedTopic: string, receivedMessage: any) => {\n      if ([topic].flat().some(rTopic => matches(rTopic, receivedTopic))) {\n        setMessage({\n          topic: receivedTopic,\n          message:\n            parserMethod?.(receivedMessage) || receivedMessage.toString(),\n        });\n      }\n    },\n    [parserMethod, topic],\n  );\n\n  useEffect(() => {\n    if (client?.connected) {\n      subscribe();\n\n      client.on('message', callback);\n    }\n    return () => {\n      client?.off('message', callback);\n    };\n  }, [callback, client, subscribe]);\n\n  return {\n    client,\n    topic,\n    message,\n    connectionStatus,\n  };\n}\n","import { useContext } from 'react';\n\nimport MqttContext from './Context';\nimport { IMqttContext as Context } from './types';\n\nexport default function useMqttState() {\n  const { connectionStatus, client, parserMethod } = useContext<Context>(\n    MqttContext,\n  );\n\n  return {\n    connectionStatus,\n    client,\n    parserMethod,\n  };\n}\n","import React, { useEffect, useState, useMemo, useRef } from 'react';\n\nimport { connect, MqttClient } from 'mqtt';\n\nimport MqttContext from './Context';\nimport { Error, ConnectorProps, IMqttContext } from './types';\n\nexport default function Connector({\n  children,\n  brokerUrl,\n  options = { keepalive: 0 },\n  parserMethod,\n}: ConnectorProps) {\n  // Using a ref rather than relying on state because it is synchronous\n  const clientValid = useRef(false);\n  const [connectionStatus, setStatus] = useState<string | Error>('Offline');\n  const [client, setClient] = useState<MqttClient | null>(null);\n\n  useEffect(() => {\n    if (!client && !clientValid.current) {\n      // This synchronously ensures we won't enter this block again\n      // before the client is asynchronously set\n      clientValid.current = true;\n      setStatus('Connecting');\n      console.log(`attempting to connect to ${brokerUrl}`);\n      const mqtt = connect(brokerUrl, options);\n      mqtt.on('connect', () => {\n        console.debug('on connect');\n        setStatus('Connected');\n        // For some reason setting the client as soon as we get it from connect breaks things\n        setClient(mqtt);\n      });\n      mqtt.on('reconnect', () => {\n        console.debug('on reconnect');\n        setStatus('Reconnecting');\n      });\n      mqtt.on('error', err => {\n        console.log(`Connection error: ${err}`);\n        setStatus(err.message);\n      });\n      mqtt.on('offline', () => {\n        console.debug('on offline');\n        setStatus('Offline');\n      });\n      mqtt.on('end', () => {\n        console.debug('on end');\n        setStatus('Offline');\n      });\n    }\n  }, [client, clientValid, brokerUrl, options]);\n\n  // Only do this when the component unmounts\n  useEffect(\n    () => () => {\n      if (client) {\n        console.log('closing mqtt client');\n        client.end(true);\n        setClient(null);\n        clientValid.current = false;\n      }\n    },\n    [client, clientValid],\n  );\n\n  // This is to satisfy\n  // https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/jsx-no-constructed-context-values.md\n  const value: IMqttContext = useMemo<IMqttContext>(\n    () => ({\n      connectionStatus,\n      client,\n      parserMethod,\n    }),\n    [connectionStatus, client, parserMethod],\n  );\n\n  return <MqttContext.Provider value={value}>{children}</MqttContext.Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}