{"ast":null,"code":"\"use strict\";\n\nvar SEPARATOR = \"/\";\nvar SINGLE = \"+\";\nvar ALL = \"#\";\nmodule.exports = {\n  matches: matches,\n  extract: extract,\n  exec: exec,\n  fill: fill,\n  clean: clean\n};\n\nfunction exec(pattern, topic) {\n  return matches(pattern, topic) ? extract(pattern, topic) : null;\n}\n\nfunction matches(pattern, topic) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var topicSegments = topic.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var topicLength = topicSegments.length;\n  var lastIndex = patternLength - 1;\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    var currentTopic = topicSegments[i];\n    if (!currentTopic && !currentPattern) continue;\n    if (!currentTopic && currentPattern !== ALL) return false; // Only allow # at end\n\n    if (patternChar === ALL) return i === lastIndex;\n    if (patternChar !== SINGLE && currentPattern !== currentTopic) return false;\n  }\n\n  return patternLength === topicLength;\n}\n\nfunction fill(pattern, params) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var result = [];\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    var patternParam = currentPattern.slice(1);\n    var paramValue = params[patternParam];\n\n    if (patternChar === ALL) {\n      // Check that it isn't undefined\n      if (paramValue !== void 0) result.push([].concat(paramValue).join(SEPARATOR)); // Ensure it's an array\n      // Since # wildcards are always at the end, break out of the loop\n\n      break;\n    } else if (patternChar === SINGLE) // Coerce param into a string, missing params will be undefined\n      result.push(\"\" + paramValue);else result.push(currentPattern);\n  }\n\n  return result.join(SEPARATOR);\n}\n\nfunction extract(pattern, topic) {\n  var params = {};\n  var patternSegments = pattern.split(SEPARATOR);\n  var topicSegments = topic.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    if (currentPattern.length === 1) continue;\n\n    if (patternChar === ALL) {\n      params[currentPattern.slice(1)] = topicSegments.slice(i);\n      break;\n    } else if (patternChar === SINGLE) {\n      params[currentPattern.slice(1)] = topicSegments[i];\n    }\n  }\n\n  return params;\n}\n\nfunction clean(pattern) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var cleanedSegments = [];\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n\n    if (patternChar === ALL) {\n      cleanedSegments.push(ALL);\n    } else if (patternChar === SINGLE) {\n      cleanedSegments.push(SINGLE);\n    } else {\n      cleanedSegments.push(currentPattern);\n    }\n  }\n\n  return cleanedSegments.join('/');\n}","map":{"version":3,"names":["SEPARATOR","SINGLE","ALL","module","exports","matches","extract","exec","fill","clean","pattern","topic","patternSegments","split","topicSegments","patternLength","length","topicLength","lastIndex","i","currentPattern","patternChar","currentTopic","params","result","patternParam","slice","paramValue","push","concat","join","cleanedSegments"],"sources":["/Users/Neutron/Project/Trisno/client/node_modules/mqtt-pattern/index.js"],"sourcesContent":["\"use strict\";\r\nvar SEPARATOR = \"/\";\r\nvar SINGLE = \"+\";\r\nvar ALL = \"#\";\r\n\r\nmodule.exports = {\r\n\tmatches: matches,\r\n\textract: extract,\r\n\texec: exec,\r\n\tfill: fill,\r\n\tclean: clean\r\n};\r\n\r\nfunction exec(pattern, topic) {\r\n\treturn matches(pattern, topic) ? extract(pattern, topic) : null;\r\n}\r\n\r\nfunction matches(pattern, topic) {\r\n\tvar patternSegments = pattern.split(SEPARATOR);\r\n\tvar topicSegments = topic.split(SEPARATOR);\r\n\r\n\tvar patternLength = patternSegments.length;\r\n\tvar topicLength = topicSegments.length;\r\n\tvar lastIndex = patternLength - 1;\r\n\r\n\tfor(var i = 0; i < patternLength; i++){\r\n\t\tvar currentPattern = patternSegments[i];\r\n\t\tvar patternChar = currentPattern[0];\r\n\t\tvar currentTopic = topicSegments[i];\r\n\r\n\t\tif(!currentTopic && !currentPattern)\r\n\t\t\tcontinue;\r\n\r\n\t\tif(!currentTopic && currentPattern !== ALL) return false;\r\n\r\n\t\t// Only allow # at end\r\n\t\tif(patternChar === ALL)\r\n\t\t\treturn i === lastIndex;\r\n\t\tif(patternChar !== SINGLE && currentPattern !== currentTopic)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn patternLength === topicLength;\r\n}\r\n\r\nfunction fill(pattern, params){\r\n\tvar patternSegments = pattern.split(SEPARATOR);\r\n\tvar patternLength = patternSegments.length;\r\n\r\n\tvar result = [];\r\n\r\n\tfor (var i = 0; i < patternLength; i++) {\r\n\t\tvar currentPattern = patternSegments[i];\r\n\t\tvar patternChar = currentPattern[0];\r\n\t\tvar patternParam = currentPattern.slice(1);\r\n\t\tvar paramValue = params[patternParam];\r\n\r\n\t\tif(patternChar === ALL){\r\n\t\t\t// Check that it isn't undefined\r\n\t\t\tif(paramValue !== void 0)\r\n\t\t\t\tresult.push([].concat(paramValue).join(SEPARATOR)); // Ensure it's an array\r\n\r\n\t\t\t// Since # wildcards are always at the end, break out of the loop\r\n\t\t\tbreak;\r\n\t\t} else if (patternChar === SINGLE)\r\n\t\t\t// Coerce param into a string, missing params will be undefined\r\n\t\t\tresult.push(\"\" + paramValue);\r\n\t\telse result.push(currentPattern);\r\n\t}\r\n\r\n\treturn result.join(SEPARATOR);\r\n}\r\n\r\n\r\nfunction extract(pattern, topic) {\r\n\tvar params = {};\r\n\tvar patternSegments = pattern.split(SEPARATOR);\r\n\tvar topicSegments = topic.split(SEPARATOR);\r\n\r\n\tvar patternLength = patternSegments.length;\r\n\r\n\tfor(var i = 0; i < patternLength; i++){\r\n\t\tvar currentPattern = patternSegments[i];\r\n\t\tvar patternChar = currentPattern[0];\r\n\r\n\t\tif(currentPattern.length === 1)\r\n\t\t\tcontinue;\r\n\r\n\t\tif(patternChar === ALL){\r\n\t\t\tparams[currentPattern.slice(1)] = topicSegments.slice(i);\r\n\t\t\tbreak;\r\n\t\t} else if(patternChar === SINGLE){\r\n\t\t\tparams[currentPattern.slice(1)] = topicSegments[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn params;\r\n}\r\n\r\n\r\nfunction clean(pattern) {\r\n\tvar patternSegments = pattern.split(SEPARATOR);\r\n\tvar patternLength = patternSegments.length;\r\n\r\n\tvar cleanedSegments = [];\r\n\r\n\tfor(var i = 0; i < patternLength; i++){\r\n\t\tvar currentPattern = patternSegments[i];\r\n\t\tvar patternChar = currentPattern[0];\r\n\r\n\t\tif(patternChar === ALL){\r\n\t\t\tcleanedSegments.push(ALL);\r\n\t\t} else if(patternChar === SINGLE){\r\n\t\t\tcleanedSegments.push(SINGLE);\r\n\t\t} else {\r\n\t\t\tcleanedSegments.push(currentPattern);\r\n\t\t}\r\n\t}\r\n\r\n\treturn cleanedSegments.join('/');\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}