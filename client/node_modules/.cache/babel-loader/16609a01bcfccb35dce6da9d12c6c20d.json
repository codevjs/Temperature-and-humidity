{"ast":null,"code":"import _regeneratorRuntime from \"/Users/Neutron/Project/Trisno/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/Neutron/Project/Trisno/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/Neutron/Project/Trisno/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport n, { createContext as e, useContext as o, useState as t, useCallback as c, useEffect as r, useRef as l, useMemo as i } from \"react\";\nimport { matches as s } from \"mqtt-pattern\";\nimport { connect as u } from \"mqtt\";\nvar a = e({});\n\nfunction f(n) {\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _o = o(a),\n      l = _o.client,\n      i = _o.connectionStatus,\n      u = _o.parserMethod,\n      _t = t(void 0),\n      _t2 = _slicedToArray(_t, 2),\n      f = _t2[0],\n      d = _t2[1],\n      g = c( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            null == l || l.subscribe(n, e);\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [l, e, n]),\n      m = c(function (e, o) {\n    [n].flat().some(function (n) {\n      return s(n, e);\n    }) && d({\n      topic: e,\n      message: (null == u ? void 0 : u(o)) || o.toString()\n    });\n  }, [u, n]);\n\n  return r(function () {\n    return (null == l ? void 0 : l.connected) && (g(), l.on(\"message\", m)), function () {\n      null == l || l.off(\"message\", m);\n    };\n  }, [m, l, g]), {\n    client: l,\n    topic: n,\n    message: f,\n    connectionStatus: i\n  };\n}\n\nfunction d() {\n  var _o2 = o(a),\n      n = _o2.connectionStatus,\n      e = _o2.client,\n      t = _o2.parserMethod;\n\n  return {\n    connectionStatus: n,\n    client: e,\n    parserMethod: t\n  };\n}\n\nfunction g(_ref2) {\n  var e = _ref2.children,\n      o = _ref2.brokerUrl,\n      _ref2$options = _ref2.options,\n      c = _ref2$options === void 0 ? {\n    keepalive: 0\n  } : _ref2$options,\n      s = _ref2.parserMethod;\n\n  var f = l(!1),\n      _t3 = t(\"Offline\"),\n      _t4 = _slicedToArray(_t3, 2),\n      d = _t4[0],\n      g = _t4[1],\n      _t5 = t(null),\n      _t6 = _slicedToArray(_t5, 2),\n      m = _t6[0],\n      p = _t6[1];\n\n  r(function () {\n    if (!m && !f.current) {\n      f.current = !0, g(\"Connecting\"), console.log(\"attempting to connect to \".concat(o));\n\n      var _n = u(o, c);\n\n      _n.on(\"connect\", function () {\n        console.debug(\"on connect\"), g(\"Connected\"), p(_n);\n      }), _n.on(\"reconnect\", function () {\n        console.debug(\"on reconnect\"), g(\"Reconnecting\");\n      }), _n.on(\"error\", function (n) {\n        console.log(\"Connection error: \".concat(n)), g(n.message);\n      }), _n.on(\"offline\", function () {\n        console.debug(\"on offline\"), g(\"Offline\");\n      }), _n.on(\"end\", function () {\n        console.debug(\"on end\"), g(\"Offline\");\n      });\n    }\n  }, [m, f, o, c]), r(function () {\n    return function () {\n      m && (console.log(\"closing mqtt client\"), m.end(!0), p(null), f.current = !1);\n    };\n  }, [m, f]);\n  var b = i(function () {\n    return {\n      connectionStatus: d,\n      client: m,\n      parserMethod: s\n    };\n  }, [d, m, s]);\n  return n.createElement(a.Provider, {\n    value: b\n  }, e);\n}\n\nexport { g as Connector, a as MqttContext, d as useMqttState, f as useSubscription };","map":{"version":3,"mappings":"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","names":["MqttContext","createContext","topic","options","useContext","client","connectionStatus","parserMethod","useState","undefined","message","setMessage","subscribe","useCallback","async","callback","receivedTopic","receivedMessage","flat","some","rTopic","matches","toString","useEffect","connected","on","off","useMqttState","Connector","children","brokerUrl","keepalive","clientValid","useRef","setStatus","setClient","current","console","log","mqtt","connect","debug","err","end","value","useMemo","React","Provider"],"sources":["/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/Context.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/useSubscription.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/useMqttState.tsx","/Users/Neutron/Project/Trisno/client/node_modules/mqtt-react-hooks/lib/Connector.tsx"],"sourcesContent":["/* istanbul ignore file */\n\nimport { createContext } from 'react';\n\nimport { IMqttContext } from './types';\n\nexport default createContext<IMqttContext>({} as IMqttContext);\n","import { useContext, useEffect, useCallback, useState } from 'react';\n\nimport { IClientSubscribeOptions } from 'mqtt';\nimport { matches } from 'mqtt-pattern';\n\nimport MqttContext from './Context';\nimport { IMqttContext as Context, IUseSubscription, IMessage } from './types';\n\nexport default function useSubscription(\n  topic: string | string[],\n  options: IClientSubscribeOptions = {} as IClientSubscribeOptions,\n): IUseSubscription {\n  const { client, connectionStatus, parserMethod } = useContext<Context>(\n    MqttContext,\n  );\n\n  const [message, setMessage] = useState<IMessage | undefined>(undefined);\n\n  const subscribe = useCallback(async () => {\n    client?.subscribe(topic, options);\n  }, [client, options, topic]);\n\n  const callback = useCallback(\n    (receivedTopic: string, receivedMessage: any) => {\n      if ([topic].flat().some(rTopic => matches(rTopic, receivedTopic))) {\n        setMessage({\n          topic: receivedTopic,\n          message:\n            parserMethod?.(receivedMessage) || receivedMessage.toString(),\n        });\n      }\n    },\n    [parserMethod, topic],\n  );\n\n  useEffect(() => {\n    if (client?.connected) {\n      subscribe();\n\n      client.on('message', callback);\n    }\n    return () => {\n      client?.off('message', callback);\n    };\n  }, [callback, client, subscribe]);\n\n  return {\n    client,\n    topic,\n    message,\n    connectionStatus,\n  };\n}\n","import { useContext } from 'react';\n\nimport MqttContext from './Context';\nimport { IMqttContext as Context } from './types';\n\nexport default function useMqttState() {\n  const { connectionStatus, client, parserMethod } = useContext<Context>(\n    MqttContext,\n  );\n\n  return {\n    connectionStatus,\n    client,\n    parserMethod,\n  };\n}\n","import React, { useEffect, useState, useMemo, useRef } from 'react';\n\nimport { connect, MqttClient } from 'mqtt';\n\nimport MqttContext from './Context';\nimport { Error, ConnectorProps, IMqttContext } from './types';\n\nexport default function Connector({\n  children,\n  brokerUrl,\n  options = { keepalive: 0 },\n  parserMethod,\n}: ConnectorProps) {\n  // Using a ref rather than relying on state because it is synchronous\n  const clientValid = useRef(false);\n  const [connectionStatus, setStatus] = useState<string | Error>('Offline');\n  const [client, setClient] = useState<MqttClient | null>(null);\n\n  useEffect(() => {\n    if (!client && !clientValid.current) {\n      // This synchronously ensures we won't enter this block again\n      // before the client is asynchronously set\n      clientValid.current = true;\n      setStatus('Connecting');\n      console.log(`attempting to connect to ${brokerUrl}`);\n      const mqtt = connect(brokerUrl, options);\n      mqtt.on('connect', () => {\n        console.debug('on connect');\n        setStatus('Connected');\n        // For some reason setting the client as soon as we get it from connect breaks things\n        setClient(mqtt);\n      });\n      mqtt.on('reconnect', () => {\n        console.debug('on reconnect');\n        setStatus('Reconnecting');\n      });\n      mqtt.on('error', err => {\n        console.log(`Connection error: ${err}`);\n        setStatus(err.message);\n      });\n      mqtt.on('offline', () => {\n        console.debug('on offline');\n        setStatus('Offline');\n      });\n      mqtt.on('end', () => {\n        console.debug('on end');\n        setStatus('Offline');\n      });\n    }\n  }, [client, clientValid, brokerUrl, options]);\n\n  // Only do this when the component unmounts\n  useEffect(\n    () => () => {\n      if (client) {\n        console.log('closing mqtt client');\n        client.end(true);\n        setClient(null);\n        clientValid.current = false;\n      }\n    },\n    [client, clientValid],\n  );\n\n  // This is to satisfy\n  // https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/jsx-no-constructed-context-values.md\n  const value: IMqttContext = useMemo<IMqttContext>(\n    () => ({\n      connectionStatus,\n      client,\n      parserMethod,\n    }),\n    [connectionStatus, client, parserMethod],\n  );\n\n  return <MqttContext.Provider value={value}>{children}</MqttContext.Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}